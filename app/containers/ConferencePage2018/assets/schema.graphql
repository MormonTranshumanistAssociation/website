# This schema was generated from 
# https://scaphold.io/apps/mta-conf/graphiql
# 
# scahpold.io discontinued service in April 2018.
#
# Output from the queries has been preserved in data.json files located
# adjacent to the components that used them.


# Values for the AccessLevel enum
enum AccessLevel {
  admin
  readwrite
  readonly
}

input AddToUserRolesConnectionInput {
  userId: ID!
  roleId: ID!
  accessLevel: AccessLevel!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type AddToUserRolesConnectionPayload {
  # The mutated UserRoles.
  changedUserRoles: UserRoles

  # An edge containing the mutated UserRoles. Use this to update your client side cache.
  changedEdge: UserRolesEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# An arbitrary object. AnyObject's are not type checked
#                   and are always returned in their entirety.
scalar AnyObject

# Identity object returned from the 'profile' in the response paylaod
#         of Auth0 Lock login.
input Auth0LockIdentity {
  userId: String!
  provider: String!
  connection: String!
  isSocial: Boolean!
  expiresIn: Int
}

interface Blob {
  blobMimeType: String
  blobUrl: String
}

input ChangeUserPasswordInput {
  id: ID!
  oldPassword: String!
  newPassword: String!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type ChangeUserPasswordPayload {
  # The mutated User.
  changedUser: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# The Conference type
type Conference implements Node, Timestamped {
  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!

  # Number of minutes to subtract from presentations to allow for setup time for the subsequent presenter.
  defaultPrepMinutes: Int
  activePresentation: Presentation

  # A globally unique ID.
  id: ID!
  presentations(where: PresentationWhereArgs, orderBy: [PresentationOrderByArgs], first: Int, after: String, last: Int, before: String): PresentationConnection
  startAt: DateTime!

  # Amount of flex that presentations can have if none is specified.
  #
  # If less than 1, treated as a percentage.
  # If 1 or more, treated as minutes.
  defaultPresentationFlex: Float

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!
  title: String
}

input ConferenceActivePresentationIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input ConferenceActivePresentationIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

type ConferenceAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # Returns the average value for fields in the connection
  avg: ConferenceAggregationsAvg

  # The sum of the values in a field
  sum: ConferenceAggregationsSum

  # The minimum value for the field
  min: ConferenceAggregationsMin

  # The maximum value for the field
  max: ConferenceAggregationsMax
}

type ConferenceAggregationsAvg {
  defaultPrepMinutes: Float
  defaultPresentationFlex: Float
}

type ConferenceAggregationsMax {
  createdAt: DateTime
  startAt: DateTime
  modifiedAt: DateTime
  defaultPrepMinutes: Int
  defaultPresentationFlex: Float
  title: String
}

type ConferenceAggregationsMin {
  createdAt: DateTime
  startAt: DateTime
  modifiedAt: DateTime
  defaultPrepMinutes: Int
  defaultPresentationFlex: Float
  title: String
}

type ConferenceAggregationsSum {
  defaultPrepMinutes: Int
  defaultPresentationFlex: Float
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type ConferenceConnection {
  # The set of edges in this page.
  edges: [ConferenceEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the Conference type.
  aggregations: ConferenceAggregations
}

input ConferenceCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input ConferenceCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input ConferenceDefaultPrepMinutesSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Int

  # Greater than.
  gt: Int

  # Greater than or equal to.
  gte: Int

  # Less than.
  lt: Int

  # Less than or equal to.
  lte: Int

  # Not equal to.
  ne: Int

  # A two element tuple describing a range of values.
  between: [Int]

  # A two element tuple describing an excluded range of values.
  notBetween: [Int]

  # A list of values to include.
  in: [Int]

  # A list of values to exclude.
  notIn: [Int]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input ConferenceDefaultPrepMinutesWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Int

  # Not equal to.
  ne: Int

  # Greater than.
  gt: Int

  # Greater than or equal to.
  gte: Int

  # Less than.
  lt: Int

  # Less than or equal to.
  lte: Int

  # A two element tuple describing a range of values.
  between: [Int]

  # A two element tuple describing an excluded range of values.
  notBetween: [Int]

  # A list of values to include.
  in: [Int]

  # A list of values to exclude.
  notIn: [Int]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input ConferenceDefaultPresentationFlexSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Float

  # Greater than.
  gt: Float

  # Greater than or equal to.
  gte: Float

  # Less than.
  lt: Float

  # Less than or equal to.
  lte: Float

  # Not equal to.
  ne: Float

  # A two element tuple describing a range of values.
  between: [Float]

  # A two element tuple describing an excluded range of values.
  notBetween: [Float]

  # A list of values to include.
  in: [Float]

  # A list of values to exclude.
  notIn: [Float]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input ConferenceDefaultPresentationFlexWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Float

  # Not equal to.
  ne: Float

  # Greater than.
  gt: Float

  # Greater than or equal to.
  gte: Float

  # Less than.
  lt: Float

  # Less than or equal to.
  lte: Float

  # A two element tuple describing a range of values.
  between: [Float]

  # A two element tuple describing an excluded range of values.
  notBetween: [Float]

  # A list of values to include.
  in: [Float]

  # A list of values to exclude.
  notIn: [Float]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type ConferenceEdge {
  # The node value for the edge.
  node: Conference!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input ConferenceIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input ConferenceIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input ConferenceModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input ConferenceModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum ConferenceMutationEvent {
  # Subscribe to this event to be notified after every createConference mutation.
  createConference

  # Subscribe to this event to be notified after every updateConference mutation.
  updateConference

  # Subscribe to this event to be notified after every deleteConference mutation.
  deleteConference
}

input ConferenceOrderByArgs {
  field: ConferenceOrderByField
  direction: OrderByDirection
}

# Values for the ConferenceOrderByField enum
enum ConferenceOrderByField {
  createdAt
  defaultPrepMinutes
  id
  startAt
  defaultPresentationFlex
  modifiedAt
  title
}

input ConferenceStartAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input ConferenceStartAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Subscription filter arguments for the Conference type
input ConferenceSubscriptionFilter {
  # Filter results for on the createdAt field.
  createdAt: ConferenceCreatedAtSubscriptionFilters

  # Filter results for on the defaultPrepMinutes field.
  defaultPrepMinutes: ConferenceDefaultPrepMinutesSubscriptionFilters

  # Filter results for on the id field.
  id: ConferenceIdSubscriptionFilters

  # Filter results for on the startAt field.
  startAt: ConferenceStartAtSubscriptionFilters

  # Filter results for on the defaultPresentationFlex field.
  defaultPresentationFlex: ConferenceDefaultPresentationFlexSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: ConferenceModifiedAtSubscriptionFilters

  # Filter results for on the title field.
  title: ConferenceTitleSubscriptionFilters

  # Filter results for on the activePresentationId field.
  activePresentationId: ConferenceActivePresentationIdSubscriptionFilters
}

# A payload wrapper for mutation operations.
type ConferenceSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: ConferenceMutationEvent

  # The object that was just mutated.
  value: Conference
  edge: ConferenceEdge
}

input ConferenceTitleSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input ConferenceTitleWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Where filter arguments for the Conference type
input ConferenceWhereArgs {
  # Filter results for on the createdAt field.
  createdAt: ConferenceCreatedAtWhereArgs

  # Filter results for on the defaultPrepMinutes field.
  defaultPrepMinutes: ConferenceDefaultPrepMinutesWhereArgs

  # Filter results based on a related object via the activePresentation connection
  activePresentation: PresentationWhereArgs

  # Filter results for on the id field.
  id: ConferenceIdWhereArgs

  # Filter results based on a related object via the presentations connection
  presentations: PresentationWhereArgs

  # Filter results for on the startAt field.
  startAt: ConferenceStartAtWhereArgs

  # Filter results for on the defaultPresentationFlex field.
  defaultPresentationFlex: ConferenceDefaultPresentationFlexWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: ConferenceModifiedAtWhereArgs

  # Filter results for on the title field.
  title: ConferenceTitleWhereArgs

  # Filter results for on the activePresentationId field.
  activePresentationId: ConferenceActivePresentationIdWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [ConferenceWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [ConferenceWhereArgs]
}

# Values for the ConnectionType enum
enum ConnectionType {
  ad
  adfs
  amazon
  dropbox
  bitbucket
  aol
  auth0_adldap
  auth0_oidc
  auth0
  baidu
  bitly
  box
  custom
  dwolla
  email
  evernote_sandbox
  evernote
  exact
  facebook
  fitbit
  flickr
  github
  google_apps
  google_oauth2
  guardian
  instagram
  ip
  linkedin
  miicard
  oauth1
  oauth2
  office365
  paypal
  pingfederate
  planningcenter
  renren
  salesforce_community
  salesforce_sandbox
  salesforce
  samlp
  sharepoint
  shopify
  sms
  soundcloud
  thecity_sandbox
  thecity
  thirtysevensignals
  twitter
  untappd
  vkontakte
  waad
  weibo
  windowslive
  wordpress
  yahoo
  yammer
  yandex
}

input CreateConferenceInput {
  defaultPrepMinutes: Int
  activePresentation: CreatePresentationInput
  activePresentationId: ID
  startAt: DateTime!
  defaultPresentationFlex: Float
  title: String
  clientMutationId: ID
}

type CreateConferencePayload {
  # The mutated Conference.
  changedConference: Conference

  # An edge containing the mutated Conference. Use this to update your client side cache.
  changedEdge: ConferenceEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input CreateFileInput {
  name: String
  presentation: CreatePresentationInput
  presentationId: ID
  blobFieldName: String
  clientMutationId: ID
}

type CreateFilePayload {
  # The mutated File.
  changedFile: File

  # An edge containing the mutated File. Use this to update your client side cache.
  changedEdge: FileEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input CreatePresentationInput {
  prepMinutes: Int
  activeConference: CreateConferenceInput
  activeConferenceId: ID
  duration: Int
  actualDuration: Int
  conference: CreateConferenceInput
  conferenceId: ID
  presenter: CreatePresenterInput
  presenterId: ID
  title: String
  flex: Float
  position: Int!
  clientMutationId: ID
}

type CreatePresentationPayload {
  # The mutated Presentation.
  changedPresentation: Presentation

  # An edge containing the mutated Presentation. Use this to update your client side cache.
  changedEdge: PresentationEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input CreatePresenterInput {
  email: String
  bio: Text
  displayName: String
  photoUrl: String
  clientMutationId: ID
}

type CreatePresenterPayload {
  # The mutated Presenter.
  changedPresenter: Presenter

  # An edge containing the mutated Presenter. Use this to update your client side cache.
  changedEdge: PresenterEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input CreateRoleInput {
  name: String!
  clientMutationId: ID
}

type CreateRolePayload {
  # The mutated Role.
  changedRole: Role

  # An edge containing the mutated Role. Use this to update your client side cache.
  changedEdge: RoleEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input CreateUserInput {
  password: Secret!
  username: String!
  clientMutationId: ID
}

type CreateUserPayload {
  # The user's authentication token. Embed this under the
  #           'Authorization' header with the format 'Bearer <token>'
  #         
  token: String

  # The mutated User.
  changedUser: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# A range aggregation that is dedicated for date values.
#       The main difference between this aggregation and the normal range
#       aggregation is that the from and to values can be expressed in Date
#       Math expressions, and it is also possible to specify a date format
#       by which the from and to response fields will be returned. Note
#       that this aggregation includes the from value and excludes the
#       to value for each range
#       
input DateRangeInput {
  # E.G. { "from": "now-10M/M" } means '>= now minus 10 months, rounded down to the start of the month.'
  from: String

  # E.G. { "to": "now-10M/M" } means '< now minus 10 months, rounded down to the start of the month.'
  to: String
}

# The `DateTime` type represents a single point in time and is stored with
#                   millisecond precision plus a time zone specified by ISO 8601. All types come
#                   preloaded with createdAt and modifiedAt timestamps that are automatically managed
#                   for you.
scalar DateTime

input DeleteConferenceInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeleteConferencePayload {
  # The mutated Conference.
  changedConference: Conference

  # An edge containing the mutated Conference. Use this to update your client side cache.
  changedEdge: ConferenceEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input DeleteFileInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeleteFilePayload {
  # The mutated File.
  changedFile: File

  # An edge containing the mutated File. Use this to update your client side cache.
  changedEdge: FileEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input DeletePresentationInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeletePresentationPayload {
  # The mutated Presentation.
  changedPresentation: Presentation

  # An edge containing the mutated Presentation. Use this to update your client side cache.
  changedEdge: PresentationEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input DeletePresenterInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeletePresenterPayload {
  # The mutated Presenter.
  changedPresenter: Presenter

  # An edge containing the mutated Presenter. Use this to update your client side cache.
  changedEdge: PresenterEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input DeleteRoleInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeleteRolePayload {
  # The mutated Role.
  changedRole: Role

  # An edge containing the mutated Role. Use this to update your client side cache.
  changedEdge: RoleEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input DeleteUserInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeleteUserPayload {
  # The mutated User.
  changedUser: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# A Scaphold User.
type Field implements Node {
  # A global id
  id: ID!
  name: String!
  description: String
  columnName: String
  nonNull: Boolean
  unique: Boolean
  indexed: Boolean
  type: String
  ofType: String
  ofTypeNonNull: Boolean
  reverseName: String
  defaultValue: AnyObject
  isEditable: Boolean
  through: String
  position: Int
}

# The File type
type File implements Node, Timestamped, Blob {
  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!

  # The name of the File. If no name is given, the uploaded file's name will be used.
  name: String

  # The mimeType of the blob asset.
  blobMimeType: String

  # A pre-signed url to your file.
  blobUrl: String

  # The reverse field of 'photo' in 1:M connection
  #             with type 'undefined'.
  presenters: PresenterConnection

  # The reverse field of 'files' in M:1 connection
  #             with type 'File'.
  presentation: Presentation

  # A globally unique ID.
  id: ID!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!
}

type FileAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # The minimum value for the field
  min: FileAggregationsMin

  # The maximum value for the field
  max: FileAggregationsMax
}

type FileAggregationsMax {
  createdAt: DateTime
  modifiedAt: DateTime
  name: String
  blobMimeType: String
  blobUrl: String
}

type FileAggregationsMin {
  createdAt: DateTime
  modifiedAt: DateTime
  name: String
  blobMimeType: String
  blobUrl: String
}

input FileBlobMimeTypeSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileBlobMimeTypeWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileBlobUrlSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileBlobUrlWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type FileConnection {
  # The set of edges in this page.
  edges: [FileEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the File type.
  aggregations: FileAggregations
}

input FileCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type FileEdge {
  # The node value for the edge.
  node: File!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input FileIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input FileIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum FileMutationEvent {
  # Subscribe to this event to be notified after every createFile mutation.
  createFile

  # Subscribe to this event to be notified after every updateFile mutation.
  updateFile

  # Subscribe to this event to be notified after every deleteFile mutation.
  deleteFile
}

input FileNameSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileNameWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileOrderByArgs {
  field: FileOrderByField
  direction: OrderByDirection
}

# Values for the FileOrderByField enum
enum FileOrderByField {
  createdAt
  name
  blobMimeType
  blobUrl
  id
  modifiedAt
}

input FilePresentationIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input FilePresentationIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Subscription filter arguments for the File type
input FileSubscriptionFilter {
  # Filter results for on the createdAt field.
  createdAt: FileCreatedAtSubscriptionFilters

  # Filter results for on the name field.
  name: FileNameSubscriptionFilters

  # Filter results for on the blobMimeType field.
  blobMimeType: FileBlobMimeTypeSubscriptionFilters

  # Filter results for on the blobUrl field.
  blobUrl: FileBlobUrlSubscriptionFilters

  # Filter results for on the id field.
  id: FileIdSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: FileModifiedAtSubscriptionFilters

  # Filter results for on the presentationId field.
  presentationId: FilePresentationIdSubscriptionFilters
}

# A payload wrapper for mutation operations.
type FileSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: FileMutationEvent

  # The object that was just mutated.
  value: File
  edge: FileEdge
}

# Where filter arguments for the File type
input FileWhereArgs {
  # Filter results for on the createdAt field.
  createdAt: FileCreatedAtWhereArgs

  # Filter results for on the name field.
  name: FileNameWhereArgs

  # Filter results for on the blobMimeType field.
  blobMimeType: FileBlobMimeTypeWhereArgs

  # Filter results for on the blobUrl field.
  blobUrl: FileBlobUrlWhereArgs

  # Filter results based on a related object via the presentation connection
  presentation: PresentationWhereArgs

  # Filter results for on the id field.
  id: FileIdWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: FileModifiedAtWhereArgs

  # Filter results for on the presentationId field.
  presentationId: FilePresentationIdWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [FileWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [FileWhereArgs]
}

type HealthStatus {
  # Returns `true` for healthy and `false` for unhealthy.
  healthy: Boolean!

  # Additional information about the health of the API.
  message: String
}

input LoginUserInput {
  username: String!
  password: String!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type LoginUserPayload {
  # The user's authentication token. Embed this under the
  #           'Authorization' header with the format 'Bearer <token>'
  #         
  token: String

  # The mutated User.
  user: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input LoginUserWithAuth0Input {
  idToken: String!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input LoginUserWithAuth0LockInput {
  # The identity from the "profile" object of the response payload from Auth0 Lock.
  identity: Auth0LockIdentity!

  # The access token of the the social authentication connection. This should be
  #           obtained via an SDK through connections like Facebook, Twitter, or Google.
  access_token: String

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type LoginUserWithAuth0LockPayload {
  # The mutated User.
  user: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type LoginUserWithAuth0Payload {
  # The mutated User.
  user: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input LoginUserWithAuth0SocialInput {
  # The access token of the the social authentication connection. This should be
  #           obtained via an SDK through connections like Facebook, Twitter, or Google.
  access_token: String!

  # The social connection name (i.e. Facebook, Google, Twitter, etc...).
  connection: ConnectionType!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type LoginUserWithAuth0SocialPayload {
  # The access token of the logged in user issued
  #             from the social authentication connection.
  access_token: String

  # The id token of the logged in user issued from the
  #             social authentication connection.
  token: String

  # The type of the token.
  token_type: String

  # The mutated User.
  user: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type MetricAggregationResult {
  value: AnyObject
  value_as_string: String
}

# A Scaphold User.
input MigrateFieldInput {
  # A global id
  id: ID
  name: String!
  description: String
  columnName: String
  nonNull: Boolean
  unique: Boolean
  indexed: Boolean
  type: String
  ofType: String
  ofTypeNonNull: Boolean
  reverseName: String
  defaultValue: AnyObject
  isEditable: Boolean
  through: String
  position: Int
}

# A scaphold type permission.
input MigratePermissionInput {
  id: ID
  scope: PermissionScopeEnum!
  userFields: [MigrateFieldInput]
  protectedFields: [MigrateFieldInput]
  roles: [MigrateRoleInput]
  create: Boolean
  read: Boolean
  update: Boolean
  delete: Boolean
  enabled: Boolean
}

# A scaphold type permission.
input MigrateRoleInput {
  id: ID!
  name: String!
}

input MigrateSchemaInput {
  id: ID!
  name: String
  description: String
  types: [MigrateTypeInput]

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type MigrateSchemaPayload {
  # The mutated Schema.
  changedSchema: Schema

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# A Scaphold User.
input MigrateTypeInput {
  # A global id
  id: ID
  name: String!
  description: String
  kind: TypeKind!
  interfaces: [String]
  fields: [MigrateFieldInput]
  permissions: [MigratePermissionInput]
  values: [String]
  isBridge: Boolean
  position: Int
  isEditable: Boolean
  isDeletable: Boolean
  isExtendable: Boolean
}

type Mutation {
  migrateSchema(input: MigrateSchemaInput!): MigrateSchemaPayload
  loginUser(input: LoginUserInput!): LoginUserPayload
  changeUserPassword(input: ChangeUserPasswordInput!): ChangeUserPasswordPayload

  # Create objects of type Presenter.
  createPresenter(input: CreatePresenterInput!): CreatePresenterPayload

  # Update objects of type Presenter.
  updatePresenter(input: UpdatePresenterInput!): UpdatePresenterPayload

  # Delete objects of type Presenter.
  deletePresenter(input: DeletePresenterInput!): DeletePresenterPayload

  # Create objects of type User.
  createUser(input: CreateUserInput!): CreateUserPayload

  # Update objects of type User.
  updateUser(input: UpdateUserInput!): UpdateUserPayload

  # Delete objects of type User.
  deleteUser(input: DeleteUserInput!): DeleteUserPayload

  # Create objects of type Role.
  createRole(input: CreateRoleInput!): CreateRolePayload

  # Update objects of type Role.
  updateRole(input: UpdateRoleInput!): UpdateRolePayload

  # Delete objects of type Role.
  deleteRole(input: DeleteRoleInput!): DeleteRolePayload

  # Create objects of type Conference.
  createConference(input: CreateConferenceInput!): CreateConferencePayload

  # Update objects of type Conference.
  updateConference(input: UpdateConferenceInput!): UpdateConferencePayload

  # Delete objects of type Conference.
  deleteConference(input: DeleteConferenceInput!): DeleteConferencePayload

  # Create objects of type Presentation.
  createPresentation(input: CreatePresentationInput!): CreatePresentationPayload

  # Update objects of type Presentation.
  updatePresentation(input: UpdatePresentationInput!): UpdatePresentationPayload

  # Delete objects of type Presentation.
  deletePresentation(input: DeletePresentationInput!): DeletePresentationPayload

  # Create objects of type File.
  createFile(input: CreateFileInput!): CreateFilePayload

  # Update objects of type File.
  updateFile(input: UpdateFileInput!): UpdateFilePayload

  # Delete objects of type File.
  deleteFile(input: DeleteFileInput!): DeleteFilePayload

  # Adds a connection between an object of type
  #     'User' and an object of type Role. You can edit
  #     the 'UserRoles' bridge type to add/remove custom fields for this connection.
  #   
  addToUserRolesConnection(input: AddToUserRolesConnectionInput!): AddToUserRolesConnectionPayload

  # Updates an existing connection between an object of type
  #     'User' and an object of type Role.
  #   
  updateUserRolesConnection(input: UpdateUserRolesConnectionInput!): UpdateUserRolesConnectionPayload

  # Removes a connection between an object of type
  #     'User' and an object of type Role.
  #   
  removeFromUserRolesConnection(input: RemoveFromUserRolesConnectionInput!): RemoveFromUserRolesConnectionPayload

  # The input object type used to log in a user with Auth0 Social
  loginUserWithAuth0Social(input: LoginUserWithAuth0SocialInput!): LoginUserWithAuth0SocialPayload

  # The input object type used to log in a user with Auth0 Lock
  loginUserWithAuth0Lock(input: LoginUserWithAuth0LockInput!): LoginUserWithAuth0LockPayload
  loginUserWithAuth0(input: LoginUserWithAuth0Input!): LoginUserWithAuth0Payload
}

type NestedResolverLogAggregation {
  doc_count: Int
  aggregations: ResolverLogAggregationSet
}

interface Node {
  id: ID!
}

# Values for the OrderByDirection enum
enum OrderByDirection {
  ASC
  DESC
}

# PageInfo must contain fields hasPreviousPage and hasNextPage,
#                 both of which return non‐null booleans.
type PageInfo {
  # hasNextPage will be false if the client is not paginating with first,
  #                     or if the client is paginating with first, and the server has determined
  #                     that the client has reached the end of the set of edges defined by their
  #                     cursors.
  hasNextPage: Boolean!

  # hasPreviousPage will be false if the client is not paginating with last,
  #                         or if the client is paginating with last, and the server has determined
  #                         that the client has reached the end of the set of edges defined by their
  #                         cursors.
  hasPreviousPage: Boolean!
}

# A scaphold type permission.
type Permission implements Node {
  id: ID!
  scope: PermissionScopeEnum!
  userFields: [Field]
  protectedFields: [Field]
  roles: [Role]
  enabled: Boolean
  create: Boolean
  read: Boolean
  update: Boolean
  delete: Boolean
  createdAt: DateTime
  modifiedAt: DateTime
}

# Values for the PermissionScopeEnum enum
enum PermissionScopeEnum {
  EVERYONE
  AUTHENTICATED
  RELATION
  ROLE
}

# The Presentation type
type Presentation implements Node, Timestamped {
  prepMinutes: Int

  # The reverse field of 'activePresentation' in M:1 connection
  #             with type 'undefined'.
  activeConference: Conference

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!

  # The reverse field of 'presentation' in 1:M connection
  #             with type 'undefined'.
  files(where: FileWhereArgs, orderBy: [FileOrderByArgs], first: Int, after: String, last: Int, before: String): FileConnection

  # Presentation time (minutes)
  duration: Int
  actualDuration: Int

  # The reverse field of 'presentations' in M:1 connection
  #             with type 'Presentation'.
  conference: Conference

  # The reverse field of 'presentations' in M:1 connection
  #             with type 'Presentation'.
  presenter: Presenter
  title: String

  # A globally unique ID.
  id: ID!

  # Amount of time that presentation can be shortened by when running over time.
  #
  # If less than 1, treated as a percentage.
  # If 1 or more, treated as minutes.
  flex: Float
  position: Int!
}

input PresentationActiveConferenceIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input PresentationActiveConferenceIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationActualDurationSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Int

  # Greater than.
  gt: Int

  # Greater than or equal to.
  gte: Int

  # Less than.
  lt: Int

  # Less than or equal to.
  lte: Int

  # Not equal to.
  ne: Int

  # A two element tuple describing a range of values.
  between: [Int]

  # A two element tuple describing an excluded range of values.
  notBetween: [Int]

  # A list of values to include.
  in: [Int]

  # A list of values to exclude.
  notIn: [Int]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationActualDurationWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Int

  # Not equal to.
  ne: Int

  # Greater than.
  gt: Int

  # Greater than or equal to.
  gte: Int

  # Less than.
  lt: Int

  # Less than or equal to.
  lte: Int

  # A two element tuple describing a range of values.
  between: [Int]

  # A two element tuple describing an excluded range of values.
  notBetween: [Int]

  # A list of values to include.
  in: [Int]

  # A list of values to exclude.
  notIn: [Int]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

type PresentationAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # Returns the average value for fields in the connection
  avg: PresentationAggregationsAvg

  # The sum of the values in a field
  sum: PresentationAggregationsSum

  # The minimum value for the field
  min: PresentationAggregationsMin

  # The maximum value for the field
  max: PresentationAggregationsMax
}

type PresentationAggregationsAvg {
  prepMinutes: Float
  duration: Float
  actualDuration: Float
  position: Float
  flex: Float
}

type PresentationAggregationsMax {
  prepMinutes: Int
  duration: Int
  actualDuration: Int
  position: Int
  modifiedAt: DateTime
  createdAt: DateTime
  title: String
  flex: Float
}

type PresentationAggregationsMin {
  prepMinutes: Int
  duration: Int
  actualDuration: Int
  position: Int
  modifiedAt: DateTime
  createdAt: DateTime
  title: String
  flex: Float
}

type PresentationAggregationsSum {
  prepMinutes: Int
  duration: Int
  actualDuration: Int
  position: Int
  flex: Float
}

input PresentationConferenceIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input PresentationConferenceIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type PresentationConnection {
  # The set of edges in this page.
  edges: [PresentationEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the Presentation type.
  aggregations: PresentationAggregations
}

input PresentationCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationDurationSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Int

  # Greater than.
  gt: Int

  # Greater than or equal to.
  gte: Int

  # Less than.
  lt: Int

  # Less than or equal to.
  lte: Int

  # Not equal to.
  ne: Int

  # A two element tuple describing a range of values.
  between: [Int]

  # A two element tuple describing an excluded range of values.
  notBetween: [Int]

  # A list of values to include.
  in: [Int]

  # A list of values to exclude.
  notIn: [Int]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationDurationWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Int

  # Not equal to.
  ne: Int

  # Greater than.
  gt: Int

  # Greater than or equal to.
  gte: Int

  # Less than.
  lt: Int

  # Less than or equal to.
  lte: Int

  # A two element tuple describing a range of values.
  between: [Int]

  # A two element tuple describing an excluded range of values.
  notBetween: [Int]

  # A list of values to include.
  in: [Int]

  # A list of values to exclude.
  notIn: [Int]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type PresentationEdge {
  # The node value for the edge.
  node: Presentation!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input PresentationFlexSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Float

  # Greater than.
  gt: Float

  # Greater than or equal to.
  gte: Float

  # Less than.
  lt: Float

  # Less than or equal to.
  lte: Float

  # Not equal to.
  ne: Float

  # A two element tuple describing a range of values.
  between: [Float]

  # A two element tuple describing an excluded range of values.
  notBetween: [Float]

  # A list of values to include.
  in: [Float]

  # A list of values to exclude.
  notIn: [Float]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationFlexWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Float

  # Not equal to.
  ne: Float

  # Greater than.
  gt: Float

  # Greater than or equal to.
  gte: Float

  # Less than.
  lt: Float

  # Less than or equal to.
  lte: Float

  # A two element tuple describing a range of values.
  between: [Float]

  # A two element tuple describing an excluded range of values.
  notBetween: [Float]

  # A list of values to include.
  in: [Float]

  # A list of values to exclude.
  notIn: [Float]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input PresentationIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum PresentationMutationEvent {
  # Subscribe to this event to be notified after every createPresentation mutation.
  createPresentation

  # Subscribe to this event to be notified after every updatePresentation mutation.
  updatePresentation

  # Subscribe to this event to be notified after every deletePresentation mutation.
  deletePresentation
}

input PresentationOrderByArgs {
  field: PresentationOrderByField
  direction: OrderByDirection
}

# Values for the PresentationOrderByField enum
enum PresentationOrderByField {
  prepMinutes
  modifiedAt
  createdAt
  duration
  actualDuration
  title
  id
  flex
  position
}

input PresentationPositionSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Int

  # Greater than.
  gt: Int

  # Greater than or equal to.
  gte: Int

  # Less than.
  lt: Int

  # Less than or equal to.
  lte: Int

  # Not equal to.
  ne: Int

  # A two element tuple describing a range of values.
  between: [Int]

  # A two element tuple describing an excluded range of values.
  notBetween: [Int]

  # A list of values to include.
  in: [Int]

  # A list of values to exclude.
  notIn: [Int]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationPositionWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Int

  # Not equal to.
  ne: Int

  # Greater than.
  gt: Int

  # Greater than or equal to.
  gte: Int

  # Less than.
  lt: Int

  # Less than or equal to.
  lte: Int

  # A two element tuple describing a range of values.
  between: [Int]

  # A two element tuple describing an excluded range of values.
  notBetween: [Int]

  # A list of values to include.
  in: [Int]

  # A list of values to exclude.
  notIn: [Int]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationPrepMinutesSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Int

  # Greater than.
  gt: Int

  # Greater than or equal to.
  gte: Int

  # Less than.
  lt: Int

  # Less than or equal to.
  lte: Int

  # Not equal to.
  ne: Int

  # A two element tuple describing a range of values.
  between: [Int]

  # A two element tuple describing an excluded range of values.
  notBetween: [Int]

  # A list of values to include.
  in: [Int]

  # A list of values to exclude.
  notIn: [Int]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationPrepMinutesWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Int

  # Not equal to.
  ne: Int

  # Greater than.
  gt: Int

  # Greater than or equal to.
  gte: Int

  # Less than.
  lt: Int

  # Less than or equal to.
  lte: Int

  # A two element tuple describing a range of values.
  between: [Int]

  # A two element tuple describing an excluded range of values.
  notBetween: [Int]

  # A list of values to include.
  in: [Int]

  # A list of values to exclude.
  notIn: [Int]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationPresenterIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input PresentationPresenterIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Subscription filter arguments for the Presentation type
input PresentationSubscriptionFilter {
  # Filter results for on the prepMinutes field.
  prepMinutes: PresentationPrepMinutesSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: PresentationModifiedAtSubscriptionFilters

  # Filter results for on the createdAt field.
  createdAt: PresentationCreatedAtSubscriptionFilters

  # Filter results for on the duration field.
  duration: PresentationDurationSubscriptionFilters

  # Filter results for on the actualDuration field.
  actualDuration: PresentationActualDurationSubscriptionFilters

  # Filter results for on the title field.
  title: PresentationTitleSubscriptionFilters

  # Filter results for on the id field.
  id: PresentationIdSubscriptionFilters

  # Filter results for on the flex field.
  flex: PresentationFlexSubscriptionFilters

  # Filter results for on the position field.
  position: PresentationPositionSubscriptionFilters

  # Filter results for on the activeConferenceId field.
  activeConferenceId: PresentationActiveConferenceIdSubscriptionFilters

  # Filter results for on the conferenceId field.
  conferenceId: PresentationConferenceIdSubscriptionFilters

  # Filter results for on the presenterId field.
  presenterId: PresentationPresenterIdSubscriptionFilters
}

# A payload wrapper for mutation operations.
type PresentationSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: PresentationMutationEvent

  # The object that was just mutated.
  value: Presentation
  edge: PresentationEdge
}

input PresentationTitleSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresentationTitleWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Where filter arguments for the Presentation type
input PresentationWhereArgs {
  # Filter results for on the prepMinutes field.
  prepMinutes: PresentationPrepMinutesWhereArgs

  # Filter results based on a related object via the activeConference connection
  activeConference: ConferenceWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: PresentationModifiedAtWhereArgs

  # Filter results for on the createdAt field.
  createdAt: PresentationCreatedAtWhereArgs

  # Filter results based on a related object via the files connection
  files: FileWhereArgs

  # Filter results for on the duration field.
  duration: PresentationDurationWhereArgs

  # Filter results for on the actualDuration field.
  actualDuration: PresentationActualDurationWhereArgs

  # Filter results based on a related object via the conference connection
  conference: ConferenceWhereArgs

  # Filter results based on a related object via the presenter connection
  presenter: PresenterWhereArgs

  # Filter results for on the title field.
  title: PresentationTitleWhereArgs

  # Filter results for on the id field.
  id: PresentationIdWhereArgs

  # Filter results for on the flex field.
  flex: PresentationFlexWhereArgs

  # Filter results for on the position field.
  position: PresentationPositionWhereArgs

  # Filter results for on the activeConferenceId field.
  activeConferenceId: PresentationActiveConferenceIdWhereArgs

  # Filter results for on the conferenceId field.
  conferenceId: PresentationConferenceIdWhereArgs

  # Filter results for on the presenterId field.
  presenterId: PresentationPresenterIdWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [PresentationWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [PresentationWhereArgs]
}

# The Presenter type
type Presenter implements Node, Timestamped {
  email: String

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!
  bio: Text
  presentations(where: PresentationWhereArgs, orderBy: [PresentationOrderByArgs], first: Int, after: String, last: Int, before: String): PresentationConnection

  # A globally unique ID.
  id: ID!
  displayName: String

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!
  photoUrl: String
}

type PresenterAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # The minimum value for the field
  min: PresenterAggregationsMin

  # The maximum value for the field
  max: PresenterAggregationsMax
}

type PresenterAggregationsMax {
  email: String
  displayName: String
  photoUrl: String
  createdAt: DateTime
  modifiedAt: DateTime
  bio: Text
}

type PresenterAggregationsMin {
  email: String
  displayName: String
  photoUrl: String
  createdAt: DateTime
  modifiedAt: DateTime
  bio: Text
}

input PresenterBioSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Text

  # Greater than.
  gt: Text

  # Greater than or equal to.
  gte: Text

  # Less than.
  lt: Text

  # Less than or equal to.
  lte: Text

  # Not equal to.
  ne: Text

  # A two element tuple describing a range of values.
  between: [Text]

  # A two element tuple describing an excluded range of values.
  notBetween: [Text]

  # A list of values to include.
  in: [Text]

  # A list of values to exclude.
  notIn: [Text]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresenterBioWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Text

  # Not equal to.
  ne: Text

  # Greater than.
  gt: Text

  # Greater than or equal to.
  gte: Text

  # Less than.
  lt: Text

  # Less than or equal to.
  lte: Text

  # A two element tuple describing a range of values.
  between: [Text]

  # A two element tuple describing an excluded range of values.
  notBetween: [Text]

  # A list of values to include.
  in: [Text]

  # A list of values to exclude.
  notIn: [Text]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type PresenterConnection {
  # The set of edges in this page.
  edges: [PresenterEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the Presenter type.
  aggregations: PresenterAggregations
}

input PresenterCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresenterCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresenterDisplayNameSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresenterDisplayNameWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type PresenterEdge {
  # The node value for the edge.
  node: Presenter!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input PresenterEmailSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresenterEmailWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresenterIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input PresenterIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresenterModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresenterModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum PresenterMutationEvent {
  # Subscribe to this event to be notified after every createPresenter mutation.
  createPresenter

  # Subscribe to this event to be notified after every updatePresenter mutation.
  updatePresenter

  # Subscribe to this event to be notified after every deletePresenter mutation.
  deletePresenter
}

input PresenterOrderByArgs {
  field: PresenterOrderByField
  direction: OrderByDirection
}

# Values for the PresenterOrderByField enum
enum PresenterOrderByField {
  email
  createdAt
  bio
  id
  displayName
  modifiedAt
  photoUrl
}

input PresenterPhotoUrlSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PresenterPhotoUrlWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Subscription filter arguments for the Presenter type
input PresenterSubscriptionFilter {
  # Filter results for on the email field.
  email: PresenterEmailSubscriptionFilters

  # Filter results for on the createdAt field.
  createdAt: PresenterCreatedAtSubscriptionFilters

  # Filter results for on the bio field.
  bio: PresenterBioSubscriptionFilters

  # Filter results for on the id field.
  id: PresenterIdSubscriptionFilters

  # Filter results for on the displayName field.
  displayName: PresenterDisplayNameSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: PresenterModifiedAtSubscriptionFilters

  # Filter results for on the photoUrl field.
  photoUrl: PresenterPhotoUrlSubscriptionFilters
}

# A payload wrapper for mutation operations.
type PresenterSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: PresenterMutationEvent

  # The object that was just mutated.
  value: Presenter
  edge: PresenterEdge
}

# Where filter arguments for the Presenter type
input PresenterWhereArgs {
  # Filter results for on the email field.
  email: PresenterEmailWhereArgs

  # Filter results for on the createdAt field.
  createdAt: PresenterCreatedAtWhereArgs

  # Filter results for on the bio field.
  bio: PresenterBioWhereArgs

  # Filter results based on a related object via the presentations connection
  presentations: PresentationWhereArgs

  # Filter results for on the id field.
  id: PresenterIdWhereArgs

  # Filter results for on the displayName field.
  displayName: PresenterDisplayNameWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: PresenterModifiedAtWhereArgs

  # Filter results for on the photoUrl field.
  photoUrl: PresenterPhotoUrlWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [PresenterWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [PresenterWhereArgs]
}

type Query {
  node(id: ID!): Node

  # Get objects of type Presenter by id.
  getPresenter(id: ID!): Presenter

  # Get objects of type User by id.
  getUser(id: ID!): User

  # Get objects of type Role by id.
  getRole(id: ID!): Role

  # Get objects of type Conference by id.
  getConference(id: ID!): Conference

  # Get objects of type Presentation by id.
  getPresentation(id: ID!): Presentation

  # Get objects of type File by id.
  getFile(id: ID!): File
  viewer: Viewer

  # Check the health of your GraphQL API by pinging the server.
  #           It will return `true` for healthy and `false` for unhealthy.
  checkHealth: HealthStatus
  searchRequestLogs: RequestLogSearchResults
}

input RemoveFromUserRolesConnectionInput {
  userId: ID!
  roleId: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type RemoveFromUserRolesConnectionPayload {
  # The mutated UserRoles.
  changedUserRoles: UserRoles

  # An edge containing the mutated UserRoles. Use this to update your client side cache.
  changedEdge: UserRolesEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# ### RequestLog
#
#         Request Logs are backed by elasticsearch and therefore offer more powerful querying and
#         analytical capabilities. We have adapted the ElasticSearch API to better fit GraphQL, but
#         the concepts remain the same. The definitive guide is a great place to start if you are
#         new to search (https://www.elastic.co/guide/en/elasticsearch/guide/current/index.html),
#         and these docs cover the API in more detail:
#         (https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)
type RequestLog implements Node {
  id: ID!
  username: String
  isAdmin: Boolean
  isBillable: Boolean
  start: DateTime
  duration: Int
  responseSizeBytes: Int
  requestMethod: String
  status: String
  errors: [String]
  resolvers: [ResolverLog]
  createdAt: DateTime!
}

type RequestLogAggregationBucket {
  doc_count: Int
  key: AnyObject
  key_as_string: String
  aggregations: RequestLogAggregationSet
}

type RequestLogAggregationSet {
  avg(field: RequestLogNumericField): MetricAggregationResult
  cardinality(field: RequestLogField, precision_threshhold: Int): MetricAggregationResult
  max(field: RequestLogNumericField): MetricAggregationResult
  min(field: RequestLogNumericField): MetricAggregationResult
  percentiles(field: RequestLogNumericField): MetricAggregationResult
  stats(field: RequestLogNumericField): StatsAggregationResult
  sum(field: RequestLogNumericField): MetricAggregationResult
  value_count(field: RequestLogNumericField): MetricAggregationResult
  date_range(field: RequestLogDateTimeField, format: String, ranges: [DateRangeInput]!): RequestLogBucketAggregation
  date_histogram(field: RequestLogDateTimeField, interval: String, format: String, time_zone: String, missing: String): RequestLogBucketAggregation
  terms(field: RequestLogStringField, size: Int, missing: String): RequestLogBucketAggregation
  filter(term: RequestLogTermFilter): RequestLogFilterAggregation
  resolvers: NestedResolverLogAggregation
}

type RequestLogBucketAggregation {
  buckets: [RequestLogAggregationBucket]
}

# Values for the RequestLogDateTimeField enum
enum RequestLogDateTimeField {
  createdAt
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type RequestLogEdge {
  # The node value for the edge.
  node: RequestLog!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

# Values for the RequestLogField enum
enum RequestLogField {
  appId
  userId
  isAdmin
  username
  isBillable
  status
  logType
  start
  createdAt
  duration
  durationHr
  responseSizeBytes
  requestMethod
  originalUrl
  errors
  resolvers
}

type RequestLogFilterAggregation {
  doc_count: Int
  aggregations: RequestLogAggregationSet
}

# Values for the RequestLogNumericField enum
enum RequestLogNumericField {
  duration
  responseSizeBytes
}

type RequestLogSearchResults {
  # Returns a set of documents satisfying the query string and pagination
  # arguments. The 'q' querystring accepts any elasticsearch query string. See
  # (https://www.elastic.co/guide/en/elasticsearch/reference/current/
  # query-dsl-query-string-query.html#query-string-syntax) for mre details.
  edges(q: String, first: Int = 50, after: String): [RequestLogEdge]

  # Run complex aggregations on your data.
  aggregations: RequestLogAggregationSet
  took: Int
}

# Values for the RequestLogStringField enum
enum RequestLogStringField {
  appId
  userId
  username
  status
  logType
  requestMethod
  originalUrl
  errors
}

input RequestLogTermFilter {
  appId: String
  userId: String
  username: String
  status: String
  logType: String
  requestMethod: String
  originalUrl: String
  errors: String
  isAdmin: Boolean
  isBillable: Boolean
  duration: Int
  responseSizeBytes: Int
}

type ResolverLog {
  parentType: String
  returnType: String
  parsedReturnType: String
  fieldName: String
  operation: String
  start: DateTime
  minDuration: Int
  maxDuration: Int
  avgDuration: Int
  totalDuration: Int
  count: Int
  path: [String]
  statuses: String
  errors: String
}

type ResolverLogAggregationBucket {
  doc_count: Int
  key: AnyObject
  key_as_string: String
  aggregations: ResolverLogAggregationSet
}

type ResolverLogAggregationSet {
  avg(field: ResolverLogNumericField): MetricAggregationResult
  cardinality(field: ResolverLogField, precision_threshhold: Int): MetricAggregationResult
  max(field: ResolverLogNumericField): MetricAggregationResult
  min(field: ResolverLogNumericField): MetricAggregationResult
  percentiles(field: ResolverLogNumericField): MetricAggregationResult
  stats(field: ResolverLogNumericField): StatsAggregationResult
  sum(field: ResolverLogNumericField): MetricAggregationResult
  value_count(field: ResolverLogNumericField): MetricAggregationResult
  date_range(field: ResolverLogDateTimeField, format: String, ranges: [DateRangeInput]!): ResolverLogBucketAggregation
  date_histogram(field: ResolverLogDateTimeField, interval: String, format: String, time_zone: String, missing: String): ResolverLogBucketAggregation
  terms(field: ResolverLogStringField, size: Int, missing: String): ResolverLogBucketAggregation
  filter(term: ResolverLogTermFilter): ResolverLogFilterAggregation
}

type ResolverLogBucketAggregation {
  buckets: [ResolverLogAggregationBucket]
}

# Values for the ResolverLogDateTimeField enum
enum ResolverLogDateTimeField {
  start
}

# Values for the ResolverLogField enum
enum ResolverLogField {
  fieldName
  operation
  start
  path
  status
  error
  totalDuration
  count
  minDuration
  maxDuration
  avgDuration
  parentType
  returnType
  parsedReturnType
}

type ResolverLogFilterAggregation {
  doc_count: Int
  aggregations: ResolverLogAggregationSet
}

# Values for the ResolverLogNumericField enum
enum ResolverLogNumericField {
  totalDuration
  count
  minDuration
  maxDuration
  avgDuration
}

# Values for the ResolverLogStringField enum
enum ResolverLogStringField {
  fieldName
  operation
  path
  status
  error
  parentType
  returnType
  parsedReturnType
}

input ResolverLogTermFilter {
  fieldName: String
  operation: String
  path: String
  status: String
  error: String
  parentType: String
  returnType: String
  parsedReturnType: String
  totalDuration: Int
  count: Int
  minDuration: Int
  maxDuration: Int
  avgDuration: Float
}

# The Role type
type Role implements Node, Timestamped {
  # A globally unique ID.
  id: ID!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # The name of the role.
  name: String!

  # The user`s belonging to this role
  members(where: UserWhereArgs, orderBy: [UserOrderByArgs], first: Int, after: String, last: Int, before: String): RoleMembersConnection

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!
}

type RoleAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # The minimum value for the field
  min: RoleAggregationsMin

  # The maximum value for the field
  max: RoleAggregationsMax
}

type RoleAggregationsMax {
  modifiedAt: DateTime
  createdAt: DateTime
  name: String
}

type RoleAggregationsMin {
  modifiedAt: DateTime
  createdAt: DateTime
  name: String
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type RoleConnection {
  # The set of edges in this page.
  edges: [RoleEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the Role type.
  aggregations: RoleAggregations
}

input RoleCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input RoleCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type RoleEdge {
  # The node value for the edge.
  node: Role!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input RoleIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input RoleIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type RoleMembersConnection {
  # The set of edges in this page.
  edges: [RoleMembersEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the User type.
  aggregations: UserAggregations
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type RoleMembersEdge {
  # The node value for the edge.
  node: User!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!

  # The access level for this user enrollment.
  accessLevel: AccessLevel!
}

# Select objects by filtering on objects in a connection
input RoleMembersWhereArgs {
  # Filter on values on the connection edge. E.G. Get all users with readonly membership to a role.
  edge: UserRolesEdgeWhereArgs

  # Filter on values in the target type. E.G. Get all users that are a member of the Executives role
  node: UserWhereArgs
}

input RoleModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input RoleModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum RoleMutationEvent {
  # Subscribe to this event to be notified after every createRole mutation.
  createRole

  # Subscribe to this event to be notified after every updateRole mutation.
  updateRole

  # Subscribe to this event to be notified after every deleteRole mutation.
  deleteRole
}

input RoleNameSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input RoleNameWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input RoleOrderByArgs {
  field: RoleOrderByField
  direction: OrderByDirection
}

# Values for the RoleOrderByField enum
enum RoleOrderByField {
  id
  modifiedAt
  name
  createdAt
}

# Subscription filter arguments for the Role type
input RoleSubscriptionFilter {
  # Filter results for on the id field.
  id: RoleIdSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: RoleModifiedAtSubscriptionFilters

  # Filter results for on the name field.
  name: RoleNameSubscriptionFilters

  # Filter results for on the createdAt field.
  createdAt: RoleCreatedAtSubscriptionFilters
}

# A payload wrapper for mutation operations.
type RoleSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: RoleMutationEvent

  # The object that was just mutated.
  value: Role
  edge: RoleEdge
}

# Where filter arguments for the Role type
input RoleWhereArgs {
  # Filter results for on the id field.
  id: RoleIdWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: RoleModifiedAtWhereArgs

  # Filter results for on the name field.
  name: RoleNameWhereArgs

  # Filter results based on a related object via the members connection
  members: RoleMembersWhereArgs

  # Filter results for on the createdAt field.
  createdAt: RoleCreatedAtWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [RoleWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [RoleWhereArgs]
}

# A Scaphold Schema.
type Schema implements Node {
  # A global id
  id: ID!
  name: String!
  description: String
  types: [Type]
  createdAt: DateTime
  modifiedAt: DateTime
}

#
#       The 'Secret' scalar type represents textual data, represented as UTF-8 that should not
#       be readable. The Secret type is often used to hide sensitive information such as passwords
#       and credentials.
#     
scalar Secret

type StatsAggregationResult {
  count: Int
  min: Float
  max: Float
  avg: Float
  sum: Float
}

type Subscription {
  subscribeToPresenter(filter: PresenterSubscriptionFilter, mutations: [PresenterMutationEvent]!): PresenterSubscriptionPayload
  subscribeToUser(filter: UserSubscriptionFilter, mutations: [UserMutationEvent]!): UserSubscriptionPayload
  subscribeToRole(filter: RoleSubscriptionFilter, mutations: [RoleMutationEvent]!): RoleSubscriptionPayload
  subscribeToConference(filter: ConferenceSubscriptionFilter, mutations: [ConferenceMutationEvent]!): ConferenceSubscriptionPayload
  subscribeToPresentation(filter: PresentationSubscriptionFilter, mutations: [PresentationMutationEvent]!): PresentationSubscriptionPayload
  subscribeToFile(filter: FileSubscriptionFilter, mutations: [FileMutationEvent]!): FileSubscriptionPayload
}

#
#       The 'Text' scalar type is like String except can hold values of much longer length.
#       The String type has a max length of 767 bytes due to indexing constraints.
#       Text on the other hand can hold values of up to a length of 2^16 bytes.
#     
scalar Text

interface Timestamped {
  createdAt: DateTime!
  modifiedAt: DateTime!
}

# A Scaphold User.
type Type implements Node {
  # A global id
  id: ID!
  name: String!
  description: String
  kind: TypeKind
  interfaces: [String]
  fields: [Field]
  permissions: [Permission]
  values: [String]
  isBridge: Boolean
  position: Int
  isEditable: Boolean
  isDeletable: Boolean
  isExtendable: Boolean
  createdAt: DateTime
  modifiedAt: DateTime
}

# Options for types that can be built on scaphold.
enum TypeKind {
  OBJECT
  ENUM
  INTERFACE
}

input UpdateConferenceInput {
  defaultPrepMinutes: Int
  activePresentationId: ID
  id: ID!
  startAt: DateTime
  defaultPresentationFlex: Float
  title: String

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdateConferencePayload {
  # The mutated Conference.
  changedConference: Conference

  # An edge containing the mutated Conference. Use this to update your client side cache.
  changedEdge: ConferenceEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdateFileInput {
  name: String
  presentationId: ID
  id: ID!
  blobFieldName: String

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdateFilePayload {
  # The mutated File.
  changedFile: File

  # An edge containing the mutated File. Use this to update your client side cache.
  changedEdge: FileEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdatePresentationInput {
  prepMinutes: Int
  activeConferenceId: ID
  duration: Int
  actualDuration: Int
  conferenceId: ID
  presenterId: ID
  title: String
  id: ID!
  flex: Float
  position: Int

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdatePresentationPayload {
  # The mutated Presentation.
  changedPresentation: Presentation

  # An edge containing the mutated Presentation. Use this to update your client side cache.
  changedEdge: PresentationEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdatePresenterInput {
  email: String
  bio: Text
  id: ID!
  displayName: String
  photoUrl: String

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdatePresenterPayload {
  # The mutated Presenter.
  changedPresenter: Presenter

  # An edge containing the mutated Presenter. Use this to update your client side cache.
  changedEdge: PresenterEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdateRoleInput {
  id: ID!
  name: String

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdateRolePayload {
  # The mutated Role.
  changedRole: Role

  # An edge containing the mutated Role. Use this to update your client side cache.
  changedEdge: RoleEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdateUserInput {
  password: Secret
  username: String
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdateUserPayload {
  # The mutated User.
  changedUser: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdateUserRolesConnectionInput {
  userId: ID!
  roleId: ID!
  accessLevel: AccessLevel!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdateUserRolesConnectionPayload {
  # The mutated UserRoles.
  changedUserRoles: UserRoles

  # An edge containing the mutated UserRoles. Use this to update your client side cache.
  changedEdge: UserRolesEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# The User type
type User implements Node, Timestamped {
  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!

  # A list of roles in which this user is enrolled
  roles(where: RoleWhereArgs, orderBy: [RoleOrderByArgs], first: Int, after: String, last: Int, before: String): UserRolesConnection

  # The user's username.
  username: String!

  # A globally unique ID.
  id: ID!

  # An automatically managed timestamp that is set every time a user logs in.
  lastLogin: DateTime!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!
}

type UserAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # The minimum value for the field
  min: UserAggregationsMin

  # The maximum value for the field
  max: UserAggregationsMax
}

type UserAggregationsMax {
  createdAt: DateTime
  lastLogin: DateTime
  modifiedAt: DateTime
  username: String
}

type UserAggregationsMin {
  createdAt: DateTime
  lastLogin: DateTime
  modifiedAt: DateTime
  username: String
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type UserConnection {
  # The set of edges in this page.
  edges: [UserEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the User type.
  aggregations: UserAggregations
}

input UserCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type UserEdge {
  # The node value for the edge.
  node: User!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input UserIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input UserIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserLastLoginSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserLastLoginWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum UserMutationEvent {
  # Subscribe to this event to be notified after every loginUser mutation.
  loginUser

  # Subscribe to this event to be notified after every createUser mutation.
  createUser

  # Subscribe to this event to be notified after every updateUser mutation.
  updateUser

  # Subscribe to this event to be notified after every deleteUser mutation.
  deleteUser
}

input UserOrderByArgs {
  field: UserOrderByField
  direction: OrderByDirection
}

# Values for the UserOrderByField enum
enum UserOrderByField {
  createdAt
  password
  username
  id
  lastLogin
  modifiedAt
}

input UserPasswordSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Secret

  # Greater than.
  gt: Secret

  # Greater than or equal to.
  gte: Secret

  # Less than.
  lt: Secret

  # Less than or equal to.
  lte: Secret

  # Not equal to.
  ne: Secret

  # A two element tuple describing a range of values.
  between: [Secret]

  # A two element tuple describing an excluded range of values.
  notBetween: [Secret]

  # A list of values to include.
  in: [Secret]

  # A list of values to exclude.
  notIn: [Secret]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserPasswordWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Secret

  # Not equal to.
  ne: Secret

  # Greater than.
  gt: Secret

  # Greater than or equal to.
  gte: Secret

  # Less than.
  lt: Secret

  # Less than or equal to.
  lte: Secret

  # A two element tuple describing a range of values.
  between: [Secret]

  # A two element tuple describing an excluded range of values.
  notBetween: [Secret]

  # A list of values to include.
  in: [Secret]

  # A list of values to exclude.
  notIn: [Secret]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# The UserRoles type
type UserRoles implements Timestamped {
  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!

  # The access level for this user enrollment.
  accessLevel: AccessLevel!
  user: User
  role: Role
}

input UserRolesAccessLevelWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: AccessLevel

  # Not equal to.
  ne: AccessLevel

  # Greater than.
  gt: AccessLevel

  # Greater than or equal to.
  gte: AccessLevel

  # Less than.
  lt: AccessLevel

  # Less than or equal to.
  lte: AccessLevel

  # A two element tuple describing a range of values.
  between: [AccessLevel]

  # A two element tuple describing an excluded range of values.
  notBetween: [AccessLevel]

  # A list of values to include.
  in: [AccessLevel]

  # A list of values to exclude.
  notIn: [AccessLevel]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type UserRolesConnection {
  # The set of edges in this page.
  edges: [UserRolesEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the Role type.
  aggregations: RoleAggregations
}

input UserRolesCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type UserRolesEdge {
  # The node value for the edge.
  node: Role!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!

  # The access level for this user enrollment.
  accessLevel: AccessLevel!
}

# Where filter arguments for the UserRoles type
input UserRolesEdgeWhereArgs {
  # Filter results based on values in the bridge model.
  modifiedAt: UserRolesModifiedAtWhereArgs

  # Filter results based on values in the bridge model.
  createdAt: UserRolesCreatedAtWhereArgs

  # Filter results based on values in the bridge model.
  accessLevel: UserRolesAccessLevelWhereArgs
}

input UserRolesModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Select objects by filtering on objects in a connection
input UserRolesWhereArgs {
  # Filter on values on the connection edge. E.G. Get all users with readonly membership to a role.
  edge: UserRolesEdgeWhereArgs

  # Filter on values in the target type. E.G. Get all users that are a member of the Executives role
  node: RoleWhereArgs
}

# Subscription filter arguments for the User type
input UserSubscriptionFilter {
  # Filter results for on the createdAt field.
  createdAt: UserCreatedAtSubscriptionFilters

  # Filter results for on the password field.
  password: UserPasswordSubscriptionFilters

  # Filter results for on the username field.
  username: UserUsernameSubscriptionFilters

  # Filter results for on the id field.
  id: UserIdSubscriptionFilters

  # Filter results for on the lastLogin field.
  lastLogin: UserLastLoginSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: UserModifiedAtSubscriptionFilters
}

# A payload wrapper for mutation operations.
type UserSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: UserMutationEvent

  # The object that was just mutated.
  value: User
  edge: UserEdge
}

input UserUsernameSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserUsernameWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Where filter arguments for the User type
input UserWhereArgs {
  # Filter results for on the createdAt field.
  createdAt: UserCreatedAtWhereArgs

  # Filter results based on a related object via the roles connection
  roles: UserRolesWhereArgs

  # Filter results for on the password field.
  password: UserPasswordWhereArgs

  # Filter results for on the username field.
  username: UserUsernameWhereArgs

  # Filter results for on the id field.
  id: UserIdWhereArgs

  # Filter results for on the lastLogin field.
  lastLogin: UserLastLoginWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: UserModifiedAtWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [UserWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [UserWhereArgs]
}

type Viewer implements Node {
  id: ID!

  # Sift through all objects of type 'Presenter'.
  allPresenters(where: PresenterWhereArgs, orderBy: [PresenterOrderByArgs], first: Int, after: String, last: Int, before: String): PresenterConnection

  # Sift through all objects of type 'User'.
  allUsers(where: UserWhereArgs, orderBy: [UserOrderByArgs], first: Int, after: String, last: Int, before: String): UserConnection

  # Sift through all objects of type 'Role'.
  allRoles(where: RoleWhereArgs, orderBy: [RoleOrderByArgs], first: Int, after: String, last: Int, before: String): RoleConnection

  # Sift through all objects of type 'Conference'.
  allConferences(where: ConferenceWhereArgs, orderBy: [ConferenceOrderByArgs], first: Int, after: String, last: Int, before: String): ConferenceConnection

  # Sift through all objects of type 'Presentation'.
  allPresentations(where: PresentationWhereArgs, orderBy: [PresentationOrderByArgs], first: Int, after: String, last: Int, before: String): PresentationConnection

  # Sift through all objects of type 'File'.
  allFiles(where: FileWhereArgs, orderBy: [FileOrderByArgs], first: Int, after: String, last: Int, before: String): FileConnection

  # Returns the currently logged in user and is also the entry point for queries that leverage RELATION scoped permissions.
  user: User
}
